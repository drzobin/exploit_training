// Code by Robin Larsson
// rl22ct@student.lnu.se
// robin.larsson@protonmail.ch
// 2019-11-11

// Tested and developed on the following versions.
//
// Ubuntu version:
// root@ubuntu:~# cat /etc/issue
// Ubuntu 18.04.3 LTS \n \l
//
// Kernel:
// root@ubuntu:~# uname -a
// Linux ubuntu 5.0.0-32-generic #34~18.04.2-Ubuntu SMP Thu Oct 10 10:36:02 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
//
// Libc version:
// root@ubuntu:~# ldd --version
// ldd (Ubuntu GLIBC 2.27-3ubuntu1) 2.27
//
// GCC version:
// root@ubuntu:~# gcc --version
// gcc (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0

// Disable PIE/ASLR global.
// echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
//
// Enable PIE/ASLR global.
// echo 2 | sudo tee /proc/sys/kernel/randomize_va_space

// gcc compile options.
//
// DEP/NX
// Enable: by default
// Disable: -zexecstack
//
// Stack Canary
// Enable: -fstack-protector-strong --param=ssp-buffer-size=4
// Disable: -fno-stack-protector
//
// Fortify Source
// Enable: -D_FORTIFY_SOURCE=2
// Disable: by default
//
// PIE
// Enable: -fPIE
// Diable: -fno-PIE
//
// Relocation table binding
// Enable: -Wl,-z,now
// Disable: -Wl,-z,lazy

// gcc compile examples.
//
// Compiling with enabled PIE, enabled NX, enabled Stack Canary, full RELRO and enabled Fortify Source.
// gcc -fstack-protector-strong --param=ssp-buffer-size=4 -fPIE -D_FORTIFY_SOURCE=2 -Wl,-z,now -o sploit_me02 sploit_me02.c
//
// Compiling with disabled stack canaries, disabled RELRO and disabled NX, disabled Foritfy Source.
// gcc -g -Wl,-z,norelro -fno-stack-protector -zexecstack -o sploit_me02 sploit_me02.c 
//
// Compiling with disabled stack canaries, full RELRO, enabled NX and enabled Fortify Source.
// gcc -g -Wl,-z,now -fno-stack-protector -D_FORTIFY_SOURCE=2 -o sploit_me02 sploit_me02.c

// Compile and setup for exploitation:
// Step 1: Disabel PIE/ASLR global.
// echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
//
// Step 2: Compile the binary.
// gcc -g -Wl,-z,now -fno-stack-protector -D_FORTIFY_SOURCE=2 -o sploit_me02 sploit_me02.c
//
// Step 3: Move binary to /root
// sudo  mv sploit_me02 /root/sploit_me02
//
// Step 4: Make root the owner.
// sudo chown root:root /root/sploit_me02
//
// Step 5: Set execution premissions.
// sudo chmod u+x /root/sploit_me02

#include<stdio.h>
#include<string.h>
#include<sys/socket.h>
#include<netdb.h>
#include<arpa/inet.h>
#include<netinet/in.h>
#include<unistd.h>
#include<stdlib.h>
#include<time.h>

// Processing incoming data.
int vuln_func(int socket)
{
    // This stack variable can be overflowed.
    char data[128];

    // Size of data read from the socket and put onto the stack var data.
    int data_on_stack_size;

    // Zero out the memory at every run.
    memset(data,0,128);

    // Message to user on socket regarding data to save on stack.
    write(socket ,"Please give me some data that i can but on the stack:\n" ,strlen("Please give me some data that i can but on the stack:\n"));

    // Read data from socket that should be saved on stack in vuln_func.
    data_on_stack_size = read(socket, data, 1024);

    return 0;
}

int main(int argc, char *argv[])
{
    int s_desc, new_s, c;
    struct sockaddr_in srv, cli;

    // Data that will be read from the socket and saved on the stack.
    char data_on_stack[1024];

    // Message to user regarding data on stack.
    char msg_stack[1024] = "Please give me some data that i can but on the stack:\n";

    // Message to user on socket.
    char msg_bye[1024] = "Thanks and good bye\n";

    // Message to user regarding data on the heap.
    char msg_heap[1024] = "Please give me some data that i can but on the heap:\n";

    // Data that will be read from socket and stored on heap.
    char *data_on_heap = malloc(1024);
    
    char *pointer_to_heap_data = malloc(1024);

    int data_on_stack_size;

    s_desc = socket(AF_INET, SOCK_STREAM, 0);

    if(s_desc == -1)
    {
        printf("Create socket error, s_desc was -1\n");
    }

    srv.sin_family = AF_INET;
    srv.sin_addr.s_addr = INADDR_ANY;
    // Listening port.
    srv.sin_port = htons(9000);

    // Bind socket.
    if( bind(s_desc,(struct sockaddr *)&srv ,sizeof(srv)))
    {
        printf("Faild to bind\n");
    }
    printf("Binding is done\n");

    // Listen for data.
    listen(s_desc, 3);

    // Accept incoming connections and process data.
    printf("Wating for incoming connections\n");
    while(1)
    {
        c = sizeof(struct sockaddr_in);
        new_s = accept(s_desc, (struct sockaddr *)&cli, (socklen_t *)&c);
      
       	printf("Connection from ip: %s\n",inet_ntoa (cli.sin_addr));

	// Filling with zeros.
	memset(data_on_stack,0,1024);
	memset(data_on_heap,0,1024);
	memset(pointer_to_heap_data,0,1024);

	// Message to user on socket regarding data on heap.
	write(new_s ,msg_heap ,strlen(msg_heap));

	// Read data from socket and save it on the heap.
	read(new_s, data_on_heap, 1024);

	// Message to user regarding memory address to heap data.
	sprintf(pointer_to_heap_data, "Heap data is stored at: %p \n", data_on_heap);
	write(new_s ,pointer_to_heap_data ,strlen(pointer_to_heap_data));

	// Print address of data on heap.
	printf("Address of data on heap: %p\n",data_on_heap);

	// This function has a stack overflow vuln.
	vuln_func(new_s);

	// Closing the socket and sleep 1.
	close(new_s);
	sleep(1);
    }
    return 0;
}
